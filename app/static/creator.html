<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SyncPit - Creator</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
    }

    #header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: #111;
      border-bottom: 1px solid #333;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      z-index: 100;
    }

    #info {
      font-size: 14px;
      color: #888;
    }

    #slug {
      color: #0f0;
      font-weight: bold;
      font-family: monospace;
    }

    #tools {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .tool-btn {
      background: #222;
      border: 1px solid #444;
      color: #fff;
      padding: 8px 16px;
      cursor: pointer;
      border-radius: 4px;
      font-size: 13px;
    }

    .tool-btn:hover {
      background: #333;
    }

    .tool-btn.active {
      background: #0f0;
      color: #000;
      border-color: #0f0;
    }

    #colorPicker {
      width: 40px;
      height: 32px;
      border: 1px solid #444;
      cursor: pointer;
      border-radius: 4px;
    }

    #canvas {
      position: fixed;
      top: 60px;
      left: 0;
      cursor: crosshair;
      background: #fff;
    }

    #canvas.panning {
      cursor: grab;
    }

    #canvas.panning:active {
      cursor: grabbing;
    }

    #status {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
    }

    #zoomInfo {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 11px;
      font-family: monospace;
      color: #888;
    }

    .connected { color: #0f0; }
    .disconnected { color: #f00; }
  </style>
</head>
<body>
  <div id="header">
    <div id="info">
      <span style="color: #fff; font-weight: bold;">The Well</span>
      <span style="color: #666;">â†’</span>
      <span style="color: #888;">Pit</span>
      <span id="slug"></span>
      <span style="color: #666; margin-left: 10px;">(Creator)</span>
    </div>
    <div id="tools">
      <button class="tool-btn active" id="penBtn">Pen</button>
      <button class="tool-btn" id="eraserBtn">Eraser</button>
      <input type="color" id="colorPicker" value="#000000">
      <button class="tool-btn" id="clearBtn">Clear All</button>
    </div>
  </div>

  <canvas id="canvas"></canvas>

  <div id="status">
    <span id="statusText" class="disconnected">Connecting...</span>
  </div>

  <div id="zoomInfo">
    Zoom: <span id="zoomLevel">100%</span> | Pan: Hold Space/Middle Mouse
  </div>

  <script type="module">
    import * as Y from 'https://cdn.jsdelivr.net/npm/yjs@13/+esm';
    import { WebsocketProvider } from 'https://cdn.jsdelivr.net/npm/y-websocket@1/+esm';

    // Extract pit slug from URL
    const pitSlug = window.location.pathname.split('/')[2];
    document.getElementById('slug').textContent = pitSlug;

    // Setup canvas
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - 60;

    // Drawing state
    let isDrawing = false;
    let currentColor = '#000000';
    let currentTool = 'pen';
    let lineWidth = 3;

    // Viewport state (for zoom/pan)
    let viewport = {
      offsetX: 0,
      offsetY: 0,
      scale: 1.0
    };

    // Pan state
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    let spacePressed = false;

    // Transform functions
    function screenToWorld(screenX, screenY) {
      return {
        x: (screenX - viewport.offsetX) / viewport.scale,
        y: (screenY - viewport.offsetY) / viewport.scale
      };
    }

    function worldToScreen(worldX, worldY) {
      return {
        x: worldX * viewport.scale + viewport.offsetX,
        y: worldY * viewport.scale + viewport.offsetY
      };
    }

    function updateZoomDisplay() {
      document.getElementById('zoomLevel').textContent = Math.round(viewport.scale * 100) + '%';
    }

    // Yjs setup
    const ydoc = new Y.Doc();
    const strokes = ydoc.getArray('strokes');

    // WebSocket connection
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}`;
    const provider = new WebsocketProvider(wsUrl, pitSlug, ydoc);

    // Awareness for ephemeral state (cursor, viewport)
    const awareness = provider.awareness;
    awareness.setLocalStateField('role', 'creator');
    awareness.setLocalStateField('viewport', viewport);

    // Broadcast viewport changes
    function broadcastViewport() {
      awareness.setLocalStateField('viewport', {
        offsetX: viewport.offsetX,
        offsetY: viewport.offsetY,
        scale: viewport.scale
      });
    }

    provider.on('status', event => {
      const statusText = document.getElementById('statusText');
      if (event.status === 'connected') {
        statusText.textContent = 'Connected';
        statusText.className = 'connected';
        broadcastViewport();
      } else {
        statusText.textContent = 'Disconnected';
        statusText.className = 'disconnected';
      }
    });

    // Tool buttons
    document.getElementById('penBtn').addEventListener('click', () => {
      currentTool = 'pen';
      document.getElementById('penBtn').classList.add('active');
      document.getElementById('eraserBtn').classList.remove('active');
    });

    document.getElementById('eraserBtn').addEventListener('click', () => {
      currentTool = 'eraser';
      document.getElementById('eraserBtn').classList.add('active');
      document.getElementById('penBtn').classList.remove('active');
    });

    document.getElementById('colorPicker').addEventListener('change', (e) => {
      currentColor = e.target.value;
      if (currentTool === 'eraser') {
        currentTool = 'pen';
        document.getElementById('penBtn').classList.add('active');
        document.getElementById('eraserBtn').classList.remove('active');
      }
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      if (confirm('Clear the entire pit?')) {
        ydoc.transact(() => {
          strokes.delete(0, strokes.length);
        });
      }
    });

    // Drawing functions
    function drawStroke(stroke) {
      if (!stroke || !stroke.points || stroke.points.length < 2) return;

      ctx.strokeStyle = stroke.color || '#000000';
      ctx.lineWidth = (stroke.width || 3) * viewport.scale;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      if (stroke.tool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.lineWidth = 20 * viewport.scale;
      } else {
        ctx.globalCompositeOperation = 'source-over';
      }

      ctx.beginPath();

      // Transform world coordinates to screen coordinates
      const start = worldToScreen(stroke.points[0].x, stroke.points[0].y);
      ctx.moveTo(start.x, start.y);

      for (let i = 1; i < stroke.points.length; i++) {
        const pt = worldToScreen(stroke.points[i].x, stroke.points[i].y);
        ctx.lineTo(pt.x, pt.y);
      }

      ctx.stroke();
    }

    function redrawCanvas() {
      // Clear entire canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw all strokes with current viewport transform
      strokes.forEach(stroke => drawStroke(stroke));
    }

    // Listen to Yjs changes
    strokes.observe(() => {
      redrawCanvas();
    });

    // Drawing interaction
    let currentStroke = null;

    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;

      // Pan mode: space key or middle mouse button
      if (spacePressed || e.button === 1) {
        isPanning = true;
        panStart = { x: screenX, y: screenY };
        canvas.classList.add('panning');
        e.preventDefault();
        return;
      }

      // Drawing mode: left mouse button
      if (e.button === 0) {
        isDrawing = true;
        const worldPos = screenToWorld(screenX, screenY);
        currentStroke = {
          points: [worldPos],
          color: currentColor,
          width: lineWidth,
          tool: currentTool
        };
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;

      // Broadcast cursor position (world coordinates)
      const worldPos = screenToWorld(screenX, screenY);
      awareness.setLocalStateField('cursor', {
        x: worldPos.x,
        y: worldPos.y
      });

      // Handle panning
      if (isPanning) {
        const dx = screenX - panStart.x;
        const dy = screenY - panStart.y;
        viewport.offsetX += dx;
        viewport.offsetY += dy;
        panStart = { x: screenX, y: screenY };
        redrawCanvas();
        broadcastViewport();
        return;
      }

      // Handle drawing
      if (!isDrawing || !currentStroke) return;

      currentStroke.points.push(worldPos);

      // Draw locally for immediate feedback
      redrawCanvas();
      drawStroke(currentStroke);
    });

    canvas.addEventListener('mouseup', (e) => {
      if (isPanning) {
        isPanning = false;
        canvas.classList.remove('panning');
      }

      if (isDrawing && currentStroke) {
        // Add stroke to Yjs document
        strokes.push([currentStroke]);
        isDrawing = false;
        currentStroke = null;
      }
    });

    canvas.addEventListener('mouseleave', () => {
      if (isPanning) {
        isPanning = false;
        canvas.classList.remove('panning');
      }

      if (isDrawing && currentStroke) {
        strokes.push([currentStroke]);
        isDrawing = false;
        currentStroke = null;
      }
    });

    // Prevent context menu on right click / middle click
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // Mouse wheel zoom
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();

      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Get world position before zoom
      const worldBefore = screenToWorld(mouseX, mouseY);

      // Calculate zoom change
      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
      const newScale = Math.min(Math.max(viewport.scale * zoomFactor, 0.1), 10);

      viewport.scale = newScale;

      // Get world position after zoom
      const worldAfter = screenToWorld(mouseX, mouseY);

      // Adjust offset to keep mouse position fixed
      viewport.offsetX += (worldAfter.x - worldBefore.x) * viewport.scale;
      viewport.offsetY += (worldAfter.y - worldBefore.y) * viewport.scale;

      updateZoomDisplay();
      redrawCanvas();
      broadcastViewport();
    });

    // Space key for panning
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && !spacePressed) {
        spacePressed = true;
        if (!isDrawing) {
          canvas.classList.add('panning');
        }
        e.preventDefault();
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.code === 'Space') {
        spacePressed = false;
        if (!isPanning) {
          canvas.classList.remove('panning');
        }
      }
    });

    // Touch support (with world coordinates)
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const screenX = touch.clientX - rect.left;
      const screenY = touch.clientY - rect.top;
      const worldPos = screenToWorld(screenX, screenY);

      isDrawing = true;
      currentStroke = {
        points: [worldPos],
        color: currentColor,
        width: lineWidth,
        tool: currentTool
      };
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!isDrawing || !currentStroke) return;

      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const screenX = touch.clientX - rect.left;
      const screenY = touch.clientY - rect.top;
      const worldPos = screenToWorld(screenX, screenY);

      currentStroke.points.push(worldPos);

      redrawCanvas();
      drawStroke(currentStroke);
    });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (isDrawing && currentStroke) {
        strokes.push([currentStroke]);
        isDrawing = false;
        currentStroke = null;
      }
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - 60;
      redrawCanvas();
    });

    // Initial draw
    redrawCanvas();
  </script>
</body>
</html>
